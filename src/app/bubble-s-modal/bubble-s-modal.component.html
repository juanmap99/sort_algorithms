<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>Bubble Sort es uno de los algoritmos de ordenamiento más sencillos y fáciles de entender en comparación al resto de alternativas, motivo por el cual es uno de los primeros introducidos al abordar el tópico. Sin embargo, debido a que implementa un enfoque de fuerza bruta para realizar el proceso de ordenamiento, la velocidad se ve fuertemente impactada, convirtiéndolo en uno de los algoritmos de ordenamiento más lentos en promedio.
            </p>
            <p>El proceso de Bubble Sort se basa en realizar múltiples iteraciones sobre el array, donde en cada iteración se "burbujea" el elemento más grande hacia el extremo derecho del array, reduciendo en uno el rango de elementos sin ordenar en cada paso.
            </p>
            <p>Bubble Sort, debido a que hace uso de la fuerza bruta a través de sucesivas iteraciones para ordenar el array, suele ser implementado de manera iterativa a través de dos ciclos for anidados.
            </p>
            <p>Bubble Sort, debido a que hace uso de la fuerza bruta a través de sucesivas iteraciones para ordenar el array, suele ser implementado de manera iterativa a través de dos ciclos for anidados.
            </p>
            <br>
            <h1>Análisis complejidad temporal</h1>
            <p>El mejor de los casos ocurre cuando el array se encuentra ordenado. En ese caso, debido a que el Bubble Sort es adaptable, la complejidad temporal es igual a O(N). Esto se debe a que, al terminar la primera iteración y detectar que no se realizaron intercambios de posiciones, el algoritmo finaliza la ejecución.</p>
            <p>Para el caso promedio, el algoritmo realiza N iteraciones, donde N es la longitud del array. En cada iteración, al realizar el proceso de burbujeo, se recorre una porción del array que guarda relación tanto para con el valor de N como la iteración actual. Debido a que durante la mayor parte del proceso este segundo ciclo for anidado es efectuado sobre un tamaño significativo de N y las constantes en Big O notation son omitidas, la complejidad temporal de Bubble sort es de O(N<sup>2</sup>).</p>
            <br>
            <h1>Análisis complejidad espacial</h1>
            <p>La complejidad espacial del Bubble Sort es O(1). Esto se debe a que ninguna de las variables auxiliares utilizadas durante el proceso de ordenamiento escala en función del tamaño del array.
            </p>
            <br>
            <h1>Propieades</h1>
            <p>Las propiedades del Bubble Sort son:</p>
            <ul>
                <li>In-Place.</li>
                <li>Adaptable.</li>
                <li>Estable.</li>
            </ul>
            <p>Bubble Sort es tanto adaptable como estable. Es adaptable ya que, en el caso de que exista un orden preestablecido, su complejidad temporal se ve reducida en gran medida. Esto sucede ya que el algoritmo es capaz de detectar dicho orden, a través de mecanismos que serán explicados en su debida sección, y finalizar el proceso de ordenamiento de manera prematura. Por otra parte, es estable ya que, debido a la naturaleza del proceso de burbujeo, la posición relativa de los elementos con valor idéntico se mantiene en el array ordenado.</p>
            <p><strong>ACLARACIÓN:</strong> Para obtener una explicación mas detallada acerca del significado de estas 
            propiedades diríjase al apartado de "Teoría".</p>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modal-content"
        [style.height]="modalHeight-90 + 'px'"
        [style.width]="modalWidth-40 + 'px'">
        <h1>Procedimiento</h1>
            <p>
                El procedimiento del Bubble Sort se puede describir de la siguiente manera:
            </p>
            <ul>
                <li><u>Paso 1:</u> Se define una variable; la cual será llamada n; cuyo valor sea igual a la longitud del array. Si bien este paso es opcional, ya que podría accederse a la longitud del array de manera constante sin necesidad de utilizar una variable, la creación de la misma aumenta la legibilidad del código.</li>
                <li><u>Paso 2:</u> Se inicia un ciclo for que recorre desde 0 hasta n, donde la variable inOrder representa el número de la iteración actual. Su nombre se debe a que por cada iteración un nuevo elemento pasa a ubicarse en su posición final en el array ordenado.</li>
            </ul>
            <p>
                Los pasos que prosiguen la explicación ocurren dentro del ciclo for que se comenzó en el Paso 2.
            </p>
            <ul>
                <li><u>Paso 3:</u> Se instancia una variable booleana llamada "swapped" y se inicializa en "false". Esta variable se utilizará para registrar si se ha realizado un intercambio de elementos durante la iteración actual. Si no se realiza ningún intercambio, se puede asumir que los elementos ya están ordenados y se termina la ejecución prematuramente. Este mecanismo es lo que le permite al Bubble sort ser un algoritmo adaptable.</li>
                <li><u>Paso 4:</u> Se inicia otro ciclo for que recorre el array desde la posición 0 hasta n - inOrder - 1. La resta n - inOrder se realiza porque después de cada iteración, los últimos inOrder elementos ya están en su posición ordenada. En cuanto a la resta por -1, la misma se utiliza debido a que el iterador comienza desde el cero,  mientras que el n cuenta el tamaño del array comenzando desde el uno.</li>
                <li><u>Paso 5:</u> Este paso ocurre dentro del ciclo for comenzado en el Paso 4. En el mismo se compara el elemento actual con el que lo prosigue y en caso de ser mayor, se realizan dos acciones: los elementos intercambian posiciones, y la variable swapped toma el valor de true. Este intercambio es lo que provoca que el elemento más grande se desplace hacia la parte derecha del rango actual, lo que el algoritmo refiere como “burbujeo”. Nótese como los valores se intercambian solo si el elemento actual es mayor al que lo prosigue, y no si son iguales. Esto permite que el Bubble Sort sea un algoritmo de ordenamiento estable.</li>
                <li><u>Paso 6:</u> Al finalizar el ciclo for descrito en el Paso 4, si el valor de la variable swapped sigue siendo false, se detiene la ejecución prematuramente utilizando un break. Como se mencionó en el Paso 3, si en una iteración no se ha realizado ningún intercambio, se puede asegurar que el array se encuentra completamente ordenado.</li>
            </ul>
        </div>
    </div>

    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>