<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>Insertion Sort es un algoritmo de ordenamiento que, si bien puede considerarse lento al igual que Selection Sort y Bubble Sort, destaca por su facilidad de comprensión y su similitud con el enfoque intuitivo que los seres humanos aplicamos en ciertas situaciones de ordenamiento en la vida cotidiana. Esta característica lo convierte en un algoritmo interesante, ya que se puede observar el traslado de un enfoque intuitivo a un set de instrucciones a ser ejecutadas.
            </p>
            <p>La lógica que subyace en Insertion Sort, al igual que otros algoritmos que recurren a la fuerza bruta, consiste en recorrer el array tantas veces como longitud el mismo tenga. Luego, en cada iteración, el elemento correspondiente a la misma se desplaza hacia la izquierda siempre que sea menor que el elemento con el cual se está comparando en ese momento. Como puede verse, esta lógica guarda similitud con el proceso natural que utilizamos al ordenar cartas en nuestras manos.</p>
            <br>
            <h1>Análisis complejidad temporal</h1>
            <p>
                Por los mismos motivos explicados en el resto de algoritmos de ordenamiento que recurren a la fuerza bruta a través del uso de un bucle externo y otro interno, la complejidad temporal es de  O(n<sup>2</sup>).
            </p>
            <br>
            <h1>Análisis complejidad espacial</h1>
            <p>
                Debido a que el proceso de ordenamiento se realiza In-place y no se hace uso de variables auxiliares que escalan respecto al tamaño del array, la complejidad espacial es O(1). 
            </p>
            <br>
            <h1>Propieades</h1>
            <p>Las propiedades del Insertion Sort son:</p>
            <ul>
                <li>In-Place.</li>
                <li>Adaptable.</li>
                <li>Estable.</li>
            </ul>
            <p><strong>ACLARACIÓN:</strong> Para obtener una explicación mas detallada acerca del significado de estas 
            propiedades diríjase al apartado de "Teoría".</p>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
             <h1>Procedimiento</h1>
             <p>
                El procedimiento seguido por el algoritmo es el siguiente:
            </p>
            <ul>
                <li><u>Paso 1:</u>Se inicia un ciclo for que recorre el array desde la posición 1 hasta la longitud total del mismo. El motivo por el cual se comienza desde la posición 1 se debe a que el proceso de ordenamiento consiste en la comparación del elemento actual para con los que lo preceden, y el elemento ubicado en la posición 0 no cuenta con elementos situados a su izquierda.</li>
                <li><u>Paso 2:</u>Se define una variable llamada reverser que toma el valor del elemento situado en el índice señalado por la iteración actual.</li>
                <li><u>Paso 3:</u>Se define una variable j, la cual toma el valor del índice actual menos uno.</li>
                <li><u>Paso 4:</u>Se inicia un ciclo while con la restricción de que j debe ser mayor o igual a 0, y que el valor de reverser debe ser menor al valor del elemento en la posición j del array.</li>
                <li><u>Paso 5:</u>Este paso ocurre dentro del ciclo while iniciado en el Paso 4 y consiste en el proceso de inserción. Existen dos maneras de lograrlo, pero en términos prácticos la diferencia es mínima y ambos métodos arriban al mismo resultado:
                <ul>
                    <li><u>Método 1:</u>En cada iteración del ciclo while, el valor del elemento en la posición "j+1" se actualiza con el valor del elemento en la posición "j", lo que desplaza los elementos mayores hacia la derecha. Luego, "j" se decrementa para continuar comparando y desplazando elementos hacia la derecha si es necesario. Finalmente, una vez fuera del ciclo while comenzado en el Paso 5, el valor de "reverser" se coloca en la posición resultante indicada por "j+1" , completando así la inserción.</li>
                    <li><u>Método 2:</u>En este método, la lógica planteada es idéntica al Método 1, con la diferencia que los elementos mayores al reverser no se desplazan a la derecha, sino que este último se desplaza hacia la izquierda a través del intercambio de valores entre posiciones.</li>
                </ul>
                </li>
            </ul>
            <p>Es importante destacar que en la herramienta se optó por el proceso de inserción planteado por el Método 2. Esto se debe a que este último presenta una mayor simplicidad en términos visuales, ya que el valor del reverser se mantiene constantemente presente en la pantalla del usuario mientras se desplaza hacia la izquierda, cosa que no ocurre en el Método 1.</p>
        </div>
    </div>
    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>
