<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>Merge Sort, al igual que Quick Sort, es un algoritmo que aborda el proceso de ordenamiento mediante la estrategia “Divide and Conquer”, en donde la diferencia principal se presenta en la metodología que este último utiliza al aplicarla.     
            </p>
            <p>La idea fundamental del Merge Sort se puede resumir de la siguiente manera: "Si divido un array en dos mitades iguales, las ordenó individualmente y luego las combinó de forma ordenada, obtendré un array completamente ordenado".    
            </p>
            <p>Merge Sort puede ser implementado tanto de manera iterativa como recursiva. Sin embargo, en la herramienta se optó por la versión recursiva debido a que la iterativa es menos común y  comprender su funcionamiento presenta una mayor complejidad que la versión recursiva.</p>
            <p>Como se puede apreciar en la idea fundamental planteada, el algoritmo presenta una naturaleza recursiva, ya que las mitades que se crean también son ordenadas utilizando la misma estrategia. Con respecto a la restricción de corte para la recursión, es que la longitud del array sea mayor a 1, ya que solo los arrays con al menos dos elementos pueden dividirse en dos mitades.</p>
            <br>
            <h1>Análisis complejidad temporal</h1>
            <p>
                El algoritmo particiona recursivamente el conjunto a ordenar en dos mitades, ordenándolas a través de la fusión ordenada de las mismas bajo una complejidad temporal proporcional a la cantidad de elementos en ambas mitades. Debido a ello, al igual que el Quick Sort, la complejidad temporal del Merge Sort es O(N*log<sub>2</sub> (N)).
            </p>
            <br>
            <h1>Análisis complejidad espacial</h1>
            <p>
                Debido a que el Merge Sort separa el array en dos mitades que guarda en variables auxiliares, cuyo tamaño escala en relación la cantidad de elementos del array a ordenar, la complejidad espacial es O(n).
            </p>
            <br>
            <h1>Propieades</h1>
            <p>Las propiedades del Merge Sort son:</p>
            <ul>
                <li>No es In-Place.</li>
                <li>No adaptable.</li>
                <li>Estable.</li>
            </ul>
            <p><strong>ACLARACIÓN:</strong> Para obtener una explicación mas detallada acerca del significado de estas 
            propiedades diríjase al apartado de "Teoría".</p>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
             <h1>Procedimiento</h1>
             <p>El proceso de ordenamiento se lleva a cabo de la siguiente manera:</p>
             <ul>
                 <li>Siempre y cuando la longitud del array sea mayor a uno, se calcula la posición que divide el array en dos partes iguales (permitiendo una diferencia de 1 en caso de arrays de longitud impar) y se llama recursivamente a la función Merge Sort para ambas mitades.</li>
                 <li>Se instancian tres índices: uno para el array original (iArr), otro para la mitad izquierda (iLeft) y otro para la mitad derecha (iRight).</li>
                 <li>Se recorren las dos mitades simultáneamente a través de un ciclo while, con la restricción de que sus índices respectivos sean menores que la longitud de la mitad a la que hacen referencia. Dentro del ciclo existen dos casos posibles:
                    <ul>
                        <li>Si el elemento de la mitad izquierda en la posición señalada por iLeft es menor que el elemento de la mitad derecha en la posición señalada por iRight, entonces el elemento del array en la posición señalada por iArr debe ser igual al valor de la mitad izquierda en la posición señalada por iLeft. Luego, tanto iLeft como iArr incrementan su valor en 1.</li>
                        <li>Si el elemento de la mitad izquierda en la posición señalada por iLeft es mayor o igual al elemento de la mitad derecha en la posición señalada por iRight, entonces el elemento del array en la posición señalada por iArr debe ser igual al valor de la mitad derecha en la posición señalada por iRight. Luego, tanto iRight como iArr incrementan su valor en 1.</li>
                    </ul>
                 </li>
                 <li>Al salir del ciclo while, una de las mitades habrá colocado todos sus valores ordenadamente en el array, mientras que la otra mitad todavía posee uno o más valores que no pudo colocar debido a la restricción impuesta en el ciclo. La mitad restante debe ser identificada y sus valores introducidos en el array de manera ordenada utilizando como referencia el índice asociado.</li>
             </ul>
        </div>
    </div>

    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>