<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>Heap Sort es un algoritmo de ordenamiento que, como bien lo indica su nombre, realiza el proceso de ordenamiento a través del uso de heaps. Las mismas pueden ser Max Heaps(cuando se busca ordenar de manera incremental) o Min Heaps(cuando se busca ordenar de manera decremental).
            </p>
            <p>Para aplicar el proceso de ordenamiento, Heap Sort realiza una operación conocida como heapificación sobre el array, convirtiéndolo en una Heap. Una Heap sigue las reglas de un Árbol Completo, pero se representa a través de un array. Debido a ello, es importante tener en cuenta las siguientes normas:
            </p>
                <ul>
                    <li>Todos los niveles de la heap se encuentran llenos, excepto el último.</li>
                    <li>Los nuevos elementos se agregan siempre en el último nivel, de izquierda a derecha.</li>
                    <li>Cada posición array[i] representa un nodo que tiene a su hijo izquierdo en la posición “i*2 + 1” y a su hijo derecho en la posición  “i*2 + 2”.</li>
                    <li>En el caso de una Max Heap, todo nodo padre es mayor que sus nodos hijos. En una Min Heap, todo nodo padre es menor que sus nodos hijos.</li>
                    <li>El índice a partir del cual se encuentran las hojas del árbol está dado por  la siguiente ecuación: array length // 2.</li>
                </ul>
            <br>
            <h1>Análisis complejidad temporal</h1>
            <p>
                El proceso de Heap Sort se basa en dos pasos fundamentales: El proceso de construcción de una Min Heap o Max Heap, y el proceso de ordenamiento a través de la extracción del elemento raíz y posterior heapificación rectificadora.
            </p>
            <p>
                En cuanto al proceso de construcción de una Heap, el mismo es realizado en tiempo lineal, lo que implica que su complejidad temporal es igual a O(N). En cuanto al segundo, la complejidad temporal es O(N*log<sub>2</sub> (N)), ya que se realizan un total de N extracciones, cada una acompañada de un proceso de heapificación de complejidad temporal igual a O(log<sub>2</sub> (N)).
            </p>
            <p>
                En otras palabras, al igual que el Quick Sort, debido a que las constantes son ignoradas,  la complejidad temporal del Heap Sort es O(N*log<sub>2</sub> (N)).
.
            </p>
            <br>
            <h1>Análisis complejidad espacial</h1>
            <p>
                Debido a que el proceso de heapificación se realiza In-place y no se hace uso de ninguna variable cuyo tamaño escale con respecto al tamaño del array a ordenar, la complejidad espacial del Heap Sort es O(1).
            </p>
            <br>
            <h1>Propieades</h1>
            <p>Las propiedades del Heap Sort son:</p>
            <ul>
                <li>In-Place.</li>
                <li>No adaptable.</li>
                <li>No estable.</li>
            </ul>
            <p><strong>ACLARACIÓN:</strong> Para obtener una explicación mas detallada acerca del significado de estas 
            propiedades diríjase al apartado de "Teoría".</p>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
             <h1>Procedimiento</h1>
             <h2>Paso 1 - Definición de variables</h2>
             <p>El primer paso consiste en definir dos variables mediante sencillos cálculos matemáticos.</p>
             <p>La primera variable, llamada nodes,  representa la cantidad de nodos presentes en el árbol completo que se representa con la heap. La cantidad de nodos es equivalente con la longitud del array.</p>
             <p>La segunda variable, llamada iUntilHasChild, responde a la pregunta: ¿En qué posición del array se encuentra el último nodo que tiene al menos un hijo? A lo que, debido a que se trata de un árbol completo, la respuesta es dada por la ecuación:  “(nodes//2)-1”</p>
             <h2>Paso 2 - Heapificación del array</h2>
             <p>Comienza un ciclo for que decrementa desde iUntilHasChild hasta 0 (inclusive), en donde se aplica el proceso de heapificación el array en la posición indicada por el índice.</p>
             <p>Es importante señalar que la explicación se desarrolla considerando un orden incremental, pero la lógica es similar para un orden decremental. Los pasos que se realizan son los siguientes:</p>
             <ul>
                <li>Se comienza con la suposición de que el nodo padre ubicado en la posición recibida por parámetro es el más grande.</li>
                <li>Se compara el valor del padre, el hijo derecho(de existir) y del hijo izquierdo(de existir) y se evalúa cual es el más grande, guardando el índice que contiene el valor más grande en una variable.</li>
                <li>Si el índice del nodo más grande difiere del índice del nodo padre recibido por parámetro, se realiza un intercambio de valores en el array entre ambos nodos. Luego, se llama a la función de heapificación de manera recursiva con el nuevo índice donde se encuentra ubicado el nodo padre, para asegurarse de que el nodo en esa posición también cumpla con las reglas de la heap.</li>
             </ul>
             <h2>Paso 3 - Proceso de ordenamiento</h2>
             <p>Para llevar a cabo el proceso de ordenamiento, se inicia un ciclo for que recorre desde el índice del último nodo hacia 0 (no inclusive). Dentro del ciclo, se realiza lo siguiente:</p>
             <ul>
                <li>Se intercambia el valor del nodo actual con el valor del nodo en la posición 0. Esto coloca el valor más grande al final del array, dado que, en una Max Heap, el nodo en la posición 0 es el nodo raíz y contiene el valor más grande.</li>
                <li>Luego del intercambio, lo más probable es que se hayan violado las reglas de la heap, ya que el nodo que ahora está en la posición 0 podría ser menor que sus hijos. En tal caso, se debe aplicar nuevamente el proceso de heapificación sobre el nodo en la posición 0, pero no sin antes reducir el tamaño de la heap en uno. Esto permite reubicar el nodo en su posición correcta, respetando las reglas de la heap, mientras se mantiene intacto el valor que fue intercambiado y se sabe que se sitúa en su posición final en el array ordenado.</li>
                <li>Una vez finalizado el ciclo for, el array se encuentra ordenado y se da por finalizada la ejecución.</li>
             </ul>
        </div>
    </div>
    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>
