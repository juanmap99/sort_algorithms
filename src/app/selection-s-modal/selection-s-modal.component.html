<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>Al igual que ocurre con Bubble Sort, Selection sort es un algoritmo sencillo de entender pero con una eficiencia temporal relativamente baja. Esto se debe a que, al igual que Bubble Sort, se implementa un enfoque de fuerza bruta para realizar el proceso de ordenamiento.
            </p>
            <p>La estrategia de ordenamiento de Selection Sort puede resumirse de manera concisa: "Recorrer el array en múltiples iteraciones, donde el número de iteración corresponde a una posición en el array. En cada iteración, encontrar el elemento más pequeño entre los valores que se encuentran a la derecha de la posición actual y realizar un intercambio con el mismo al encontrarlo. Al concluir las iteraciones, el array estará ordenado de manera ascendente."</p>
            <p>Al igual que sucede con Bubble Sort, debido a que hace uso de la fuerza bruta a través de sucesivas iteraciones para ordenar el array, Selection Sort suele ser implementado de manera iterativa a través de dos ciclos for anidados.</p>
            <br>
            <h1>Análisis complejidad temporal</h1>
            <p>
                El Selection Sort utiliza un bucle externo que recorre la totalidad del array. Dentro de este bucle, sobre cada iteración, un segundo ciclo anidado recorre todos los elementos ubicados a su derecha. Esto implica un recorrido proporcional al tamaño del array realizado un número de veces que equivale al tamaño del array. Debido a ello, la complejidad temporal del Selection Sort es de  O(n<sup>2</sup>).
            </p>
            <br>
            <h1>Análisis complejidad espacial</h1>
            <p>
                Debido a que el proceso de ordenamiento se realiza In-place y no se hace uso de variables auxiliares que escalan en función del tamaño del array, la complejidad espacial es O(1).
            </p>
            <br>
            <h1>Propieades</h1>
            <p>Las propiedades del Selection Sort son:</p>
            <ul>
                <li>In-Place.</li>
                <li>No Adaptable.</li>
                <li>Estable.</li>
            </ul>
            <p>En su versión estándar, Selection Sort  no es un algoritmo de ordenamiento adaptativo. Esto se debe a que, sobre cada iteración, el mismo no cuenta con otro método de determinar el elemento con valor más pequeño que no sea recorrer la totalidad de elementos ubicados a su derecha. Sin embargo, Selection Sort si es un algoritmo estable, lo que significa que la posición relativa de elementos con valores idénticos se mantiene en el array ordenado.</p>
            <p><strong>ACLARACIÓN:</strong> Para obtener una explicación mas detallada acerca del significado de estas 
            propiedades diríjase al apartado de "Teoría".</p>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
             <h1>Procedimiento</h1>
             <p>
                El procedimiento que el Selection Sort emplea para realizar el ordenamiento puede ser resumido en los siguientes puntos:
            </p>
            <ul>
                <li><u>Paso 1:</u> Se inicia un ciclo for que recorre la totalidad del array.</li>
            </ul>
            <p>Los pasos que prosiguen la explicación ocurren dentro del ciclo for comenzado en el Paso 1.</p>
            <ul>
                <li><u>Paso 2:</u> Se establece una variable llamada min_idx que representa la posición del índice que contiene el valor más pequeño. En un principio, la misma se inicializa con el número de la iteración actual.</li>
                <li><u>Paso 3:</u> Se inicia un segundo ciclo for que recorre desde la posición actual hasta el final del array. Sobre cada iteración de este bucle, si el valor en el array correspondiente a la posición indicada por min_idx es mayor que el valor al que apunta el índice de esta iteración, entonces se actualiza min_idx con el valor de este índice. Nótese como min_idx solo se actualiza al encontrar un valor menor, no igual. Esto permite que el Selection Sort sea un algoritmo estable.</li>
                <li><u>Paso 4:</u> Si el valor de min_idx es diferente al número de la iteración actual, implica que se encontró un elemento a la derecha del mismo que posee un valor menor que este. Debido a ello, se procede a intercambiar los valores en las posiciones indicadas por min_idx y el índice actual en el array.</li>
            </ul>
        </div>
    </div>
    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>

